#!/usr/bin/perl

use Glib qw(TRUE FALSE);
use Gtk2;
use Gtk2::Notify;
use Gtk2::Unique;
use Net::DBus;
use Net::DBus::GLib;

Gtk2->init;
Gtk2::Notify->init("sd-applet");

my $app;

# -----------------------------------------------------------
package Sd;
use strict;

use constant {
	FILE_COLUMN_NAME    => 0,
	FILE_COLUMN_STATUS  => 1,
	FILE_COLUMN_TOOLTIP => 2,
	UNIT_COLUMN_0	    => 0, # Id: name
	UNIT_COLUMN_1	    => 1, # Description: description
	UNIT_COLUMN_2	    => 2, # LoadState: (loaded|error)
	UNIT_COLUMN_3	    => 3, # ActiveState: (active|inactive)
	UNIT_COLUMN_4	    => 4, # SubState: (active|dead|exited|listening|mounted|plugged|running|waiting)
	UNIT_COLUMN_5	    => 5, # Following: device name (swap too)
	UNIT_COLUMN_6	    => 6, # object_path dbus node
	UNIT_COLUMN_7	    => 7, # Job.Id: always zero it seems
	UNIT_COLUMN_8	    => 8, # Job type: always empty it seems
	UNIT_COLUMN_9	    => 9, # Job.ObjectPath: another dbus node (seems to be the same as 6)
	UNIT_COLUMN_10	    =>10, # type (derived from name)
	UNIT_COLUMN_11	    =>11, # shortened name
};

# -----------------------------------------------------------
package Sd::Manager;
use base qw(Net::DBus::RemoteObject);
use strict;

sub new {
	my $srv = Net::DBus::GLib->system->get_service('org.freedesktop.systemd1');
	my $self = bless $srv->get_object('/org/freedesktop/systemd1'), shift;
	my $appl = shift;
	$self->{properties} = $self->GetAll('org.freedesktop.systemd1.Manager');
	foreach my $id ('UnitNew', 'UnitRemoved', 'JobNew', 'StartupFinished', 'UnitFilesChanged',
			'PropertiesChanged') {
		my $call = $id;
		$self->{sigids}{$id} = $self->connect_to_signal($id,sub{ $appl->$call($self,@_); });
	}
	return $self;
}
sub destroy {
	my $self = shift;
	while (my ($name,$sigid) = each %{$self->{sigids}}) {
		$self->disconnect_from_signal($name, $sigid);
	}
}

# -----------------------------------------------------------
package Sd::UnitProps;
use base qw(Gtk2::Window);
use Glib qw(TRUE FALSE);
use strict;

use constant {
	Properties=>{
		Unit=>[
			'Id',
			'Names',
			'Following',
			'Requires',
			'RequiresOverridable',
			'Requisite',
			'RequisiteOverridable',
			'Wants',
			'BindsTo',
			'RequiredBy',
			'RequiredByOverridable',
			'WantedBy',
			'BoundBy',
			'Conflicts',
			'ConflictedBy',
			'Before',
			'After',
			'OnFailure',
			'Triggers',
			'TriggeredBy',
			'PropagatesReloadTo',
			'ReloadPropagatedFrom',
			'RequiresMountsFor',
			'Description',
			'SourcePath',
			'Documentation',
			'LoadState',
			'ActiveState',
			'SubState',
			'FragmentPath',
			'UnitFileState',
			'InactiveExitTimestamp',
			'InactiveExitTimestampMonotonic',
			'ActiveEnterTimestamp',
			'ActiveEnterTimestampMonotonic',
			'ActiveExitTimestamp',
			'ActiveExitTimestampMonotonic',
			'InactiveEnterTimestamp',
			'InactiveEnterTimestampMonotonic',
			'CanStart',
			'CanStop',
			'CanReload',
			'CanIsolate',
			'Job',
			'StopWhenUnneeded',
			'RefuseManualStart',
			'RefuseManualStop',
			'AllowIsolate',
			'DefaultDependencies',
			'OnFailureIsolate',
			'IgnoreOnIsolate',
			'IgnoreOnSnapshot',
			'DefaultControlGroup',
			'ControlGroup',
			'ControlGroupAttributes',
			'NeedDaemonReload',
			'JobTimeoutUSec',
			'ConditionTimestamp',
			'ConditionTimestampMonotonic',
			'ConditionResult',
			'LoadError',
		],
		Automount=>[
			'Where',
			'DirectoryMode',
			'Result',
		],
		Device=>[
			'SysFSPath',
		],
		Mount=>[
			'Where',
			'What',
			'Options',
			'Type',
			'TimeoutUSec',
			'ExecMount',
			'ExecUnmount',
			'ExecRemount',
			'Environment',
			'UMask',
			'LimitCPU',
			'LimitFSIZE',
			'LimitDATA',
			'LimitSTACK',
			'LimitCORE',
			'LimitRSS',
			'LimitNOFILE',
			'LimitAS',
			'LimitNPROC',
			'LimitMEMLOCK',
			'LimitLOCKS',
			'LimitSIGPENDING',
			'LimitMSGQUEUE',
			'LimitNICE',
			'LimitRTPRIO',
			'LimitRTTIME',
			'WorkingDirectory',
			'RootDirectory',
			'OOMScoreAdjust',
			'Nice',
			'IOScheduling',
			'CPUSchedulingPolicy',
			'CPUSchedulingPriority',
			'CPUAffinity',
			'TimerSlackNS',
			'CPUSchedulingResetOnFork',
			'NonBlocking',
			'StandardInput',
			'StandardOutput',
			'StandardError',
			'TTYPath',
			'TTYReset',
			'TTYVHangup',
			'TTYVTDisallocate',
			'SyslogPriority',
			'SyslogIdentifier',
			'SyslogLevelPrefix',
			'Capabilities',
			'SecureBits',
			'CapabilityBoundingSet',
			'User',
			'Group',
			'SupplementaryGroups',
			'TCPWrapName',
			'PAMName',
			'ReadWriteDirectories',
			'ReadOnlyDirectories',
			'InaccessibleDirectories',
			'MountFlags',
			'PrivateTmp',
			'SameProcessGroup',
			'KillMode',
			'KillSignal',
			'UtmpIdentifier',
			'ControlGroupModify',
			'ControlGroupPersistent',
			'PrivateNetwork',
			'IgnoreSIGPIPE',
			'NoNewPrivileges',
			'SystemCallFilter',
			'KillMode',
			'KillSignal',
			'SendSIGKILL',
			'ControlPID',
			'DirectoryMode',
			'Result',
		],
		Path=>[
			'Unit',
			'Paths',
			'MakeDirectory',
			'DirectoryMode',
			'Result',
		],
		Service=>[
			'Type',
			'Restart',
			'PIDFile',
			'NotifyAccess',
			'RestartUSec',
			'TimeoutUSec',
			'WatchdogUSec',
			'WatchdogTimestamp',
			'WatchdogTimestampMonotonic',
			'StartLimitInterval',
			'StartLimitBurst',
			'StartLimitAction',
			'ExecStartPre',
			'ExecStart',
			'ExecStartPost',
			'ExecReload',
			'ExecStop',
			'ExecStopPost',
			'Environment',
			'UMask',
			'LimitCPU',
			'LimitFSIZE',
			'LimitDATA',
			'LimitSTACK',
			'LimitCORE',
			'LimitRSS',
			'LimitNOFILE',
			'LimitAS',
			'LimitNPROC',
			'LimitMEMLOCK',
			'LimitLOCKS',
			'LimitSIGPENDING',
			'LimitMSGQUEUE',
			'LimitNICE',
			'LimitRTPRIO',
			'LimitRTTIME',
			'WorkingDirectory',
			'RootDirectory',
			'OOMScoreAdjust',
			'Nice',
			'IOScheduling',
			'CPUSchedulingPolicy',
			'CPUSchedulingPriority',
			'CPUAffinity',
			'TimerSlackNS',
			'CPUSchedulingResetOnFork',
			'NonBlocking',
			'StandardInput',
			'StandardOutput',
			'StandardError',
			'TTYPath',
			'TTYReset',
			'TTYVHangup',
			'TTYVTDisallocate',
			'SyslogPriority',
			'SyslogIdentifier',
			'SyslogLevelPrefix',
			'Capabilities',
			'SecureBits',
			'CapabilityBoundingSet',
			'User',
			'Group',
			'SupplementaryGroups',
			'TCPWrapName',
			'PAMName',
			'ReadWriteDirectories',
			'ReadOnlyDirectories',
			'InaccessibleDirectories',
			'MountFlags',
			'PrivateTmp',
			'SameProcessGroup',
			'KillMode',
			'KillSignal',
			'UtmpIdentifier',
			'ControlGroupModify',
			'ControlGroupPersistent',
			'PrivateNetwork',
			'IgnoreSIGPIPE',
			'NoNewPrivileges',
			'SystemCallFilter',
			'KillMode',
			'KillSignal',
			'SendSIGKILL',
			'PermissionsStartOnly',
			'RootDirectoryStartOnly',
			'RemainAfterExit',
			'ExecMainStartTimestamp',
			'ExecMainStartTimestampMonotonic',
			'ExecMainExitTimestamp',
			'ExecMainExitTimestampMonotonic',
			'ExecMainPID',
			'ExecMainCode',
			'ExecMainStatus',
			'MainPID',
			'ControlPID',
			'BusName',
			'StatusText',
			'Result',
		],
		Socket=>[
			'BindIPv6Only',
			'Backlog',
			'TimeoutUSec',
			'ExecStartPre',
			'ExecStartPost',
			'ExecStopPre',
			'ExecStopPost',
			'Environment',
			'UMask',
			'LimitCPU',
			'LimitFSIZE',
			'LimitDATA',
			'LimitSTACK',
			'LimitCORE',
			'LimitRSS',
			'LimitNOFILE',
			'LimitAS',
			'LimitNPROC',
			'LimitMEMLOCK',
			'LimitLOCKS',
			'LimitSIGPENDING',
			'LimitMSGQUEUE',
			'LimitNICE',
			'LimitRTPRIO',
			'LimitRTTIME',
			'WorkingDirectory',
			'RootDirectory',
			'OOMScoreAdjust',
			'Nice',
			'IOScheduling',
			'CPUSchedulingPolicy',
			'CPUSchedulingPriority',
			'CPUAffinity',
			'TimerSlackNS',
			'CPUSchedulingResetOnFork',
			'NonBlocking',
			'StandardInput',
			'StandardOutput',
			'StandardError',
			'TTYPath',
			'TTYReset',
			'TTYVHangup',
			'TTYVTDisallocate',
			'SyslogPriority',
			'SyslogIdentifier',
			'SyslogLevelPrefix',
			'Capabilities',
			'SecureBits',
			'CapabilityBoundingSet',
			'User',
			'Group',
			'SupplementaryGroups',
			'TCPWrapName',
			'PAMName',
			'ReadWriteDirectories',
			'ReadOnlyDirectories',
			'InaccessibleDirectories',
			'MountFlags',
			'PrivateTmp',
			'SameProcessGroup',
			'KillMode',
			'KillSignal',
			'UtmpIdentifier',
			'ControlGroupModify',
			'ControlGroupPersistent',
			'PrivateNetwork',
			'IgnoreSIGPIPE',
			'NoNewPrivileges',
			'SystemCallFilter',
			'KillMode',
			'KillSignal',
			'SendSIGKILL',
			'ControlPID',
			'BindToDevice',
			'DirectoryMode',
			'SocketMode',
			'Accept',
			'KeepAlive',
			'Priority',
			'ReceiveBuffer',
			'SendBuffer',
			'IPTOS',
			'IPTTL',
			'PipeSize',
			'FreeBind',
			'Transparent',
			'Broadcast',
			'PassCredentials',
			'PassSecurity',
			'Mark',
			'MaxConnections',
			'NAccepted',
			'NConnections',
			'MessageQueueMaxMessages',
			'MessageQueueMessageSize',
			'Result',
			'SmackLabel',
			'SmackLabelIPIn',
			'SmackLabelIPOut',
		],
		Swap=>[
			'What',
			'Priority',
			'TimeoutUSec',
			'ExecActivate',
			'ExecDeactivate',
			'Environment',
			'UMask',
			'LimitCPU',
			'LimitFSIZE',
			'LimitDATA',
			'LimitSTACK',
			'LimitCORE',
			'LimitRSS',
			'LimitNOFILE',
			'LimitAS',
			'LimitNPROC',
			'LimitMEMLOCK',
			'LimitLOCKS',
			'LimitSIGPENDING',
			'LimitMSGQUEUE',
			'LimitNICE',
			'LimitRTPRIO',
			'LimitRTTIME',
			'WorkingDirectory',
			'RootDirectory',
			'OOMScoreAdjust',
			'Nice',
			'IOScheduling',
			'CPUSchedulingPolicy',
			'CPUSchedulingPriority',
			'CPUAffinity',
			'TimerSlackNS',
			'CPUSchedulingResetOnFork',
			'NonBlocking',
			'StandardInput',
			'StandardOutput',
			'StandardError',
			'TTYPath',
			'TTYReset',
			'TTYVHangup',
			'TTYVTDisallocate',
			'SyslogPriority',
			'SyslogIdentifier',
			'SyslogLevelPrefix',
			'Capabilities',
			'SecureBits',
			'CapabilityBoundingSet',
			'User',
			'Group',
			'SupplementaryGroups',
			'TCPWrapName',
			'PAMName',
			'ReadWriteDirectories',
			'ReadOnlyDirectories',
			'InaccessibleDirectories',
			'MountFlags',
			'PrivateTmp',
			'SameProcessGroup',
			'KillMode',
			'KillSignal',
			'UtmpIdentifier',
			'ControlGroupModify',
			'ControlGroupPersistent',
			'PrivateNetwork',
			'IgnoreSIGPIPE',
			'NoNewPrivileges',
			'SystemCallFilter',
			'KillMode',
			'KillSignal',
			'SendSIGKILL',
			'ControlPID',
			'Result',
		],
		Target=>[
		],
		Timer=>[
			'Unit',
			'Timers',
			'NextElapseUSec',
			'Result',
		],
	},
	Formats=>{
		Unit=>{
			Id=>'s',
			Names=>'as',
			Following=>'s',
			Requires=>'as',
			RequiresOverridable=>'as',
			Requisite=>'as',
			RequisiteOverridable=>'as',
			Wants=>'as',
			BindsTo=>'as',
			RequiredBy=>'as',
			RequiredByOverridable=>'as',
			WantedBy=>'as',
			BoundBy=>'as',
			Conflicts=>'as',
			ConflictedBy=>'as',
			Before=>'as',
			After=>'as',
			OnFailure=>'as',
			Triggers=>'as',
			TriggeredBy=>'as',
			PropagatesReloadTo=>'as',
			ReloadPropagatedFrom=>'as',
			RequiresMountsFor=>'as',
			Description=>'s',
			SourcePath=>'s',
			Documentation=>'as',
			LoadState=>'s',
			ActiveState=>'s',
			SubState=>'s',
			FragmentPath=>'s',
			UnitFileState=>'s',
			InactiveExitTimestamp=>'t',
			InactiveExitTimestampMonotonic=>'t',
			ActiveEnterTimestamp=>'t',
			ActiveEnterTimestampMonotonic=>'t',
			ActiveExitTimestamp=>'t',
			ActiveExitTimestampMonotonic=>'t',
			InactiveEnterTimestamp=>'t',
			InactiveEnterTimestampMonotonic=>'t',
			CanStart=>'b',
			CanStop=>'b',
			CanReload=>'b',
			CanIsolate=>'b',
			Job=>'(uo)',
			StopWhenUnneeded=>'b',
			RefuseManualStart=>'b',
			RefuseManualStop=>'b',
			AllowIsolate=>'b',
			DefaultDependencies=>'b',
			OnFailureIsolate=>'b',
			IgnoreOnIsolate=>'b',
			IgnoreOnSnapshot=>'b',
			DefaultControlGroup=>'s',
			ControlGroup=>'as',
			ControlGroupAttributes=>'a(sss)',
			NeedDaemonReload=>'b',
			JobTimeoutUSec=>'t',
			ConditionTimestamp=>'t',
			ConditionTimestampMonotonic=>'t',
			ConditionResult=>'b',
			LoadError=>'(ss)',
		},
		Automount=>{
			Where=>'s',
			DirectoryMode=>'u',
			Result=>'s',
		},
		Device=>{
			SysFSPath=>'s',
		},
		Mount=>{
			Where=>'s',
			What=>'s',
			Options=>'s',
			Type=>'s',
			TimeoutUSec=>'t',
			ExecMount=>'a(sasbttuii)',
			ExecUnmount=>'a(sasbttuii)',
			ExecRemount=>'a(sasbttuii)',
			Environment=>'as',
			UMask=>'u',
			LimitCPU=>'t',
			LimitFSIZE=>'t',
			LimitDATA=>'t',
			LimitSTACK=>'t',
			LimitCORE=>'t',
			LimitRSS=>'t',
			LimitNOFILE=>'t',
			LimitAS=>'t',
			LimitNPROC=>'t',
			LimitMEMLOCK=>'t',
			LimitLOCKS=>'t',
			LimitSIGPENDING=>'t',
			LimitMSGQUEUE=>'t',
			LimitNICE=>'t',
			LimitRTPRIO=>'t',
			LimitRTTIME=>'t',
			WorkingDirectory=>'s',
			RootDirectory=>'s',
			OOMScoreAdjust=>'i',
			Nice=>'i',
			IOScheduling=>'i',
			CPUSchedulingPolicy=>'i',
			CPUSchedulingPriority=>'i',
			CPUAffinity=>'ay',
			TimerSlackNS=>'t',
			CPUSchedulingResetOnFork=>'b',
			NonBlocking=>'b',
			StandardInput=>'s',
			StandardOutput=>'s',
			StandardError=>'s',
			TTYPath=>'s',
			TTYReset=>'b',
			TTYVHangup=>'b',
			TTYVTDisallocate=>'b',
			SyslogPriority=>'i',
			SyslogIdentifier=>'s',
			SyslogLevelPrefix=>'b',
			Capabilities=>'s',
			SecureBits=>'i',
			CapabilityBoundingSet=>'t',
			User=>'s',
			Group=>'s',
			SupplementaryGroups=>'as',
			TCPWrapName=>'s',
			PAMName=>'s',
			ReadWriteDirectories=>'as',
			ReadOnlyDirectories=>'as',
			InaccessibleDirectories=>'as',
			MountFlags=>'t',
			PrivateTmp=>'b',
			SameProcessGroup=>'b',
			KillMode=>'s',
			KillSignal=>'i',
			UtmpIdentifier=>'s',
			ControlGroupModify=>'b',
			ControlGroupPersistent=>'b',
			PrivateNetwork=>'b',
			IgnoreSIGPIPE=>'b',
			NoNewPrivileges=>'b',
			SystemCallFilter=>'au',
			KillMode=>'s',
			KillSignal=>'i',
			SendSIGKILL=>'b',
			ControlPID=>'u',
			DirectoryMode=>'u',
			Result=>'s',
		},
		Path=>{
			Unit=>'s',
			Paths=>'a(ss)',
			MakeDirectory=>'b',
			DirectoryMode=>'u',
			Result=>'s',
		},
		Service=>{
			Type=>'s',
			Restart=>'s',
			PIDFile=>'s',
			NotifyAccess=>'s',
			RestartUSec=>'t',
			TimeoutUSec=>'t',
			WatchdogUSec=>'t',
			WatchdogTimestamp=>'t',
			WatchdogTimestampMonotonic=>'t',
			StartLimitInterval=>'t',
			StartLimitBurst=>'u',
			StartLimitAction=>'s',
			ExecStartPre=>'a(sasbttuii)',
			ExecStart=>'a(sasbttuii)',
			ExecStartPost=>'a(sasbttuii)',
			ExecReload=>'a(sasbttuii)',
			ExecStop=>'a(sasbttuii)',
			ExecStopPost=>'a(sasbttuii)',
			Environment=>'as',
			UMask=>'u',
			LimitCPU=>'t',
			LimitFSIZE=>'t',
			LimitDATA=>'t',
			LimitSTACK=>'t',
			LimitCORE=>'t',
			LimitRSS=>'t',
			LimitNOFILE=>'t',
			LimitAS=>'t',
			LimitNPROC=>'t',
			LimitMEMLOCK=>'t',
			LimitLOCKS=>'t',
			LimitSIGPENDING=>'t',
			LimitMSGQUEUE=>'t',
			LimitNICE=>'t',
			LimitRTPRIO=>'t',
			LimitRTTIME=>'t',
			WorkingDirectory=>'s',
			RootDirectory=>'s',
			OOMScoreAdjust=>'i',
			Nice=>'i',
			IOScheduling=>'i',
			CPUSchedulingPolicy=>'i',
			CPUSchedulingPriority=>'i',
			CPUAffinity=>'ay',
			TimerSlackNS=>'t',
			CPUSchedulingResetOnFork=>'b',
			NonBlocking=>'b',
			StandardInput=>'s',
			StandardOutput=>'s',
			StandardError=>'s',
			TTYPath=>'s',
			TTYReset=>'b',
			TTYVHangup=>'b',
			TTYVTDisallocate=>'b',
			SyslogPriority=>'i',
			SyslogIdentifier=>'s',
			SyslogLevelPrefix=>'b',
			Capabilities=>'s',
			SecureBits=>'i',
			CapabilityBoundingSet=>'t',
			User=>'s',
			Group=>'s',
			SupplementaryGroups=>'as',
			TCPWrapName=>'s',
			PAMName=>'s',
			ReadWriteDirectories=>'as',
			ReadOnlyDirectories=>'as',
			InaccessibleDirectories=>'as',
			MountFlags=>'t',
			PrivateTmp=>'b',
			SameProcessGroup=>'b',
			KillMode=>'s',
			KillSignal=>'i',
			UtmpIdentifier=>'s',
			ControlGroupModify=>'b',
			ControlGroupPersistent=>'b',
			PrivateNetwork=>'b',
			IgnoreSIGPIPE=>'b',
			NoNewPrivileges=>'b',
			SystemCallFilter=>'au',
			KillMode=>'s',
			KillSignal=>'i',
			SendSIGKILL=>'b',
			PermissionsStartOnly=>'b',
			RootDirectoryStartOnly=>'b',
			RemainAfterExit=>'b',
			ExecMainStartTimestamp=>'t',
			ExecMainStartTimestampMonotonic=>'t',
			ExecMainExitTimestamp=>'t',
			ExecMainExitTimestampMonotonic=>'t',
			ExecMainPID=>'u',
			ExecMainCode=>'i',
			ExecMainStatus=>'i',
			MainPID=>'u',
			ControlPID=>'u',
			BusName=>'s',
			StatusText=>'s',
			Result=>'s',
		},
		Socket=>{
			BindIPv6Only=>'b',
			Backlog=>'u',
			TimeoutUSec=>'t',
			ExecStartPre=>'a(sasbttuii)',
			ExecStartPost=>'a(sasbttuii)',
			ExecStopPre=>'a(sasbttuii)',
			ExecStopPost=>'a(sasbttuii)',
			Environment=>'as',
			UMask=>'u',
			LimitCPU=>'t',
			LimitFSIZE=>'t',
			LimitDATA=>'t',
			LimitSTACK=>'t',
			LimitCORE=>'t',
			LimitRSS=>'t',
			LimitNOFILE=>'t',
			LimitAS=>'t',
			LimitNPROC=>'t',
			LimitMEMLOCK=>'t',
			LimitLOCKS=>'t',
			LimitSIGPENDING=>'t',
			LimitMSGQUEUE=>'t',
			LimitNICE=>'t',
			LimitRTPRIO=>'t',
			LimitRTTIME=>'t',
			WorkingDirectory=>'s',
			RootDirectory=>'s',
			OOMScoreAdjust=>'i',
			Nice=>'i',
			IOScheduling=>'i',
			CPUSchedulingPolicy=>'i',
			CPUSchedulingPriority=>'i',
			CPUAffinity=>'ay',
			TimerSlackNS=>'t',
			CPUSchedulingResetOnFork=>'b',
			NonBlocking=>'b',
			StandardInput=>'s',
			StandardOutput=>'s',
			StandardError=>'s',
			TTYPath=>'s',
			TTYReset=>'b',
			TTYVHangup=>'b',
			TTYVTDisallocate=>'b',
			SyslogPriority=>'i',
			SyslogIdentifier=>'s',
			SyslogLevelPrefix=>'b',
			Capabilities=>'s',
			SecureBits=>'i',
			CapabilityBoundingSet=>'t',
			User=>'s',
			Group=>'s',
			SupplementaryGroups=>'as',
			TCPWrapName=>'s',
			PAMName=>'s',
			ReadWriteDirectories=>'as',
			ReadOnlyDirectories=>'as',
			InaccessibleDirectories=>'as',
			MountFlags=>'t',
			PrivateTmp=>'b',
			SameProcessGroup=>'b',
			KillMode=>'s',
			KillSignal=>'i',
			UtmpIdentifier=>'s',
			ControlGroupModify=>'b',
			ControlGroupPersistent=>'b',
			PrivateNetwork=>'b',
			IgnoreSIGPIPE=>'b',
			NoNewPrivileges=>'b',
			SystemCallFilter=>'au',
			KillMode=>'s',
			KillSignal=>'i',
			SendSIGKILL=>'b',
			ControlPID=>'u',
			BindToDevice=>'s',
			DirectoryMode=>'u',
			SocketMode=>'u',
			Accept=>'b',
			KeepAlive=>'b',
			Priority=>'i',
			ReceiveBuffer=>'t',
			SendBuffer=>'t',
			IPTOS=>'i',
			IPTTL=>'i',
			PipeSize=>'t',
			FreeBind=>'b',
			Transparent=>'b',
			Broadcast=>'b',
			PassCredentials=>'b',
			PassSecurity=>'b',
			Mark=>'i',
			MaxConnections=>'u',
			NAccepted=>'u',
			NConnections=>'u',
			MessageQueueMaxMessages=>'x',
			MessageQueueMessageSize=>'x',
			Result=>'s',
			SmackLabel=>'s',
			SmackLabelIPIn=>'s',
			SmackLabelIPOut=>'s',
		},
		Swap=>{
			What=>'s',
			Priority=>'i',
			TimeoutUSec=>'t',
			ExecActivate=>'a(sasbttuii)',
			ExecDeactivate=>'a(sasbttuii)',
			Environment=>'as',
			UMask=>'u',
			LimitCPU=>'t',
			LimitFSIZE=>'t',
			LimitDATA=>'t',
			LimitSTACK=>'t',
			LimitCORE=>'t',
			LimitRSS=>'t',
			LimitNOFILE=>'t',
			LimitAS=>'t',
			LimitNPROC=>'t',
			LimitMEMLOCK=>'t',
			LimitLOCKS=>'t',
			LimitSIGPENDING=>'t',
			LimitMSGQUEUE=>'t',
			LimitNICE=>'t',
			LimitRTPRIO=>'t',
			LimitRTTIME=>'t',
			WorkingDirectory=>'s',
			RootDirectory=>'s',
			OOMScoreAdjust=>'i',
			Nice=>'i',
			IOScheduling=>'i',
			CPUSchedulingPolicy=>'i',
			CPUSchedulingPriority=>'i',
			CPUAffinity=>'ay',
			TimerSlackNS=>'t',
			CPUSchedulingResetOnFork=>'b',
			NonBlocking=>'b',
			StandardInput=>'s',
			StandardOutput=>'s',
			StandardError=>'s',
			TTYPath=>'s',
			TTYReset=>'b',
			TTYVHangup=>'b',
			TTYVTDisallocate=>'b',
			SyslogPriority=>'i',
			SyslogIdentifier=>'s',
			SyslogLevelPrefix=>'b',
			Capabilities=>'s',
			SecureBits=>'i',
			CapabilityBoundingSet=>'t',
			User=>'s',
			Group=>'s',
			SupplementaryGroups=>'as',
			TCPWrapName=>'s',
			PAMName=>'s',
			ReadWriteDirectories=>'as',
			ReadOnlyDirectories=>'as',
			InaccessibleDirectories=>'as',
			MountFlags=>'t',
			PrivateTmp=>'b',
			SameProcessGroup=>'b',
			KillMode=>'s',
			KillSignal=>'i',
			UtmpIdentifier=>'s',
			ControlGroupModify=>'b',
			ControlGroupPersistent=>'b',
			PrivateNetwork=>'b',
			IgnoreSIGPIPE=>'b',
			NoNewPrivileges=>'b',
			SystemCallFilter=>'au',
			KillMode=>'s',
			KillSignal=>'i',
			SendSIGKILL=>'b',
			ControlPID=>'u',
			Result=>'s',
		},
		Target=>{
		},
		Timer=>{
			Unit=>'s',
			Timers=>'a(stt)',
			NextElapseUSec=>'t',
			Result=>'s',
		},
	},
};

our $unitProps;

sub get {
	return $unitProps if $unitProps;
	return new Sd::UnitProps;
}
sub add_tree_column {
	my ($view,$label,$id,$sort) = @_;
	my $renderer = Gtk2::CellRendererText->new;
	my $offset = $view->insert_column_with_attributes(
			-1,$label,$renderer,markup=>$id);
	my $column = $view->get_column($offset - 1);
	$column->set_clickable(TRUE);
	$column->set_sort_column_id($id) if $sort;
}
sub new {
	my $self = bless Gtk2::Window->new('toplevel'), shift;
	$self->set_wmclass('sdUnitProps','SdApplet');
	$self->set_title('Unit Properties');
	$self->set_gravity('center');
	$self->set_icon_name('applications-system');
	$self->signal_connect(destroy=>sub{$unitProps=undef; 1});
	$self->set_border_width(8);

	my $vbox = Gtk2::VBox->new(FALSE,8);
	$self->add($vbox);

	my $sw = Gtk2::ScrolledWindow->new;
	$sw->set_shadow_type('etched-in');
	$sw->set_policy('never','automatic');
	$vbox->pack_start($sw,TRUE,TRUE,0);

	my $model = Gtk2::TreeStore->new(
		'Glib::String',
		'Glib::String',
	);
	$self->{store} = $model;

	my $view = Gtk2::TreeView->new($model);
	$view->set_rules_hint(TRUE);
	$view->set_search_column(0);
#	$view->set_hover_expand(1);
	$sw->add($view);
	$self->{view} = $view;

	my @columns = (
		['Property',	0,	1],
		['Value',	1,	1],
	);

	foreach my $col (@columns) { add_tree_column($view,@$col); }

	$self->set_default_size(-1,400);
	$self->show_all;

	$unitProps = $self;
	return $self;
}
sub show_props {
	my $selection = shift;
	my ($model,$iter) = $selection->get_selected;
	return unless $model;
	my $id = $model->Gtk2::TreeModel::get($iter,&Sd::UNIT_COLUMN_0);
	my $unit = $model->{objects}{$id};
	return unless $unit;
	my $utype = $unit->{utype};
	my $ptype = $unit->{ptype};
	my $uprops = $unit->GetAll("org.freedesktop.systemd1.Unit");
	my $pprops = $unit->GetAll("org.freedesktop.systemd1.$ptype");

	my $self = get Sd::UnitProps;
	my $store = $self->{store};
	$store->clear;
	$iter = $store->append(undef);
	$store->set($iter,
		0,  'Unit',
		1,  '',
	);
	foreach my $key (@{&Properties->{Unit}}) {
		next unless exists $uprops->{$key};
		my $val = $uprops->{$key};
		next unless defined $val;
		#next unless $val;
		next if $val eq '' or (ref($val) eq 'ARRAY' and @$val == 0);
		if (ref($val) eq 'ARRAY') {
			$val = join("\n",map {ref($_) eq 'ARRAY'?join("\n\t",map {ref($_) eq 'ARRAY'?join(" ",@$_):$_} @$_):$_} @$val);
		}
		if ($val =~ /ARRAY/ and ref($val) ne 'ARRAY') {
			$val = join(" ",split(/\n/,$val));
			$val = "<span foreground=\"red\"><i>Ugly value $val</i></span>";
		}
		my $citer = $store->append($iter);
		$store->set($citer,
			0, $key,
			1, $val,
		);
	}
	$iter = $store->append(undef);
	$store->set($iter,
		0,  $ptype,
		1,  '',
	);
	foreach my $key (@{&Properties->{$ptype}}) {
		next unless exists $pprops->{$key};
		my $val = $pprops->{$key};
		next unless defined $val;
		#next unless $val;
		next if $val eq '' or (ref($val) eq 'ARRAY' and @$val == 0);
		if (ref($val) eq 'ARRAY') {
			$val = join("\n",map {ref($_) eq 'ARRAY'?join("\n\t",map {ref($_) eq 'ARRAY'?join(" ",@$_):$_} @$_):$_} @$val);
		}
		if ($val =~ /ARRAY/ and ref($val) ne 'ARRAY') {
			$val = join(" ",split(/\n/,$val));
			$val = "<span foreground=\"red\"><i>Ugly value $val</i></span>";
		}
		my $citer = $store->append($iter);
		$store->set($citer,
			0, $key,
			1, $val,
		);
	}
	if (ref($model) eq 'Sd::UnitModel') {
		$self->set_screen(Sd::UnitWindow->get->get_screen);
	}
	$self->{view}->expand_row(Gtk2::TreePath->new('1'),TRUE);
	$self->deiconify;
	$self->show;
}

# -----------------------------------------------------------
package Sd::UnitModel;
use base qw(Gtk2::TreeStore);
use strict;

our $unitModel;

sub get {
	return $unitModel if $unitModel;
	return new Sd::UnitModel;
}
sub new {
	$unitModel = bless Gtk2::TreeStore->new(
		'Glib::String',	# 0 (s)
		'Glib::String',	# 1 (s)
		'Glib::String',	# 2 (s)
		'Glib::String',	# 3 (s)
		'Glib::String',	# 4 (s)
		'Glib::String',	# 5 (s)
		'Glib::String',	# 6 (o) # for now
		'Glib::String',	# 7 (u) # for now
		'Glib::String',	# 8 (s) #
		'Glib::String',	# 9 (o) # for now
		'Glib::String',	#10 (s)
		'Glib::String',	#11 (s)
	), shift;
	$unitModel->{count} = 0;
	my $i = 0;
	foreach my $kind (qw/Automount Device Mount Path Service Socket Swap Target Timer/) {
		my $iter = $unitModel->append(undef);
		$unitModel->set($iter,&Sd::UNIT_COLUMN_11,$kind);
		$unitModel->{index}{$kind} = $i;
		$i++;
	}
	return $unitModel;
}


# -----------------------------------------------------------
package Sd::Unit;
use base qw(Net::DBus::RemoteObject);
use strict;

sub new {
	my ($type,$appl) = (shift,shift);
	my $mngr = $appl->{mngr};
	my $self = bless $mngr->get_service->get_object($_[6]), $type;
	my $id = $_[0];
	$self->{id} = $id;
	my $utype = $_[0]; $utype =~ s/^.*\.//;
	$self->{utype} = $utype;
	my $ptype = uc(substr($utype,0,1)).substr($utype,1,12);
	$self->{ptype} = $ptype;

	# basically when we go to display detailed information we can
	# obtain the properties of both .Unit and other (e.g. .Device)
	# interfaces as well.  Only the Unit has methods as follows:
	#
	#   job(o) = Start(mode(s))
	#   job(o) = Stop(mode(s))
	#   job(o) = Reload(mode(s))
	#   job(o) = Restart(mode(s))
	#   job(o) = TryRestart(mode(s))
	#   job(o) = ReloadOrRestart(mode(s))
	#   job(o) = ReloadOrTryRestart(mode(s))
	#   Kill(who(s),signal(i))
	#

	$_[1] = $self->Get('org.freedesktop.systemd1.Unit','Description') unless defined $_[1];
	$_[2] = $self->Get('org.freedesktop.systemd1.Unit','LoadState')   unless defined $_[2];
	$_[3] = $self->Get('org.freedesktop.systemd1.Unit','ActiveState') unless defined $_[3];
	$_[4] = $self->Get('org.freedesktop.systemd1.Unit','SubState')    unless defined $_[4];
	$_[5] = $self->Get('org.freedesktop.systemd1.Unit','Following')   unless defined $_[5];
	$_[7] = $self->Get('org.freedesktop.systemd1.Unit','Job')->[0]    unless defined $_[7];
	$_[9] = $self->Get('org.freedesktop.systemd1.Unit','Job')->[1]    unless defined $_[9];

#	print STDERR "Getting properties for Unit\n";
#	$self->{props}{unit} = $self->GetAll("org.freedesktop.systemd1.Unit");
#	print STDERR "Getting properties for $ptype\n";
#	$self->{props}{$utype} = $self->GetAll("org.freedesktop.systemd1.$ptype");

	# No signals

	my $sname = $_[0];
	$sname = substr($sname,0,40).'...' if length($sname) > 43;

	my $store = get Sd::UnitModel;
	$store->{count}++;
	$store->{objects}{$_[0]} = $self;
	my $piter = $store->iter_nth_child(undef, $store->{index}{$ptype});
	my $iter = $store->append($piter);
	$_[2] = "<span foreground=\"green\">$_[2]</span>" if $_[2] =~ /loaded/;
	$_[2] = "<span foreground=\"red\">$_[2]</span>" if $_[2] =~ /error/;
	$_[3] = "<span foreground=\"green\">$_[3]</span>" if $_[3] =~ /\bactive/;
	$_[3] = "<span foreground=\"blue\">$_[3]</span>" if $_[3] =~ /inactive/;
	$_[4] = "<span foreground=\"green\">$_[4]</span>" if $_[4] =~ /running/;
	$_[4] = "<span foreground=\"blue\">$_[4]</span>" if $_[4] =~ /dead/;
	$_[4] = "<span foreground=\"black\">$_[4]</span>" if $_[4] =~ /exited/;
	$store->set($iter,
		&Sd::UNIT_COLUMN_0,		$_[0],
		&Sd::UNIT_COLUMN_1,		$_[1],
		&Sd::UNIT_COLUMN_2,		$_[2],
		&Sd::UNIT_COLUMN_3,		$_[3],
		&Sd::UNIT_COLUMN_4,		$_[4],
		&Sd::UNIT_COLUMN_5,		$_[5],
		&Sd::UNIT_COLUMN_6,		$_[6],
		&Sd::UNIT_COLUMN_7,		$_[7],
		&Sd::UNIT_COLUMN_8,		$_[8],
		&Sd::UNIT_COLUMN_9,		$_[9],
#		&Sd::UNIT_COLUMN_10,		$utype,
		&Sd::UNIT_COLUMN_11,		$sname,
	);
	$iter = $store->iter_nth_child($piter,0);
	my ($loaded,$error,$active,$inactive,$alive,$dead,$exited,$total);
	while ($iter) {
		my ($amloaded,$amactive,$amalive) =
			$store->Gtk2::TreeModel::get($iter,
				&Sd::UNIT_COLUMN_2,
				&Sd::UNIT_COLUMN_3,
				&Sd::UNIT_COLUMN_4,
			);
		$loaded++   if $amloaded =~ /loaded/;
		$error++    if $amloaded =~ /error/;
		$active++   if $amactive =~ /\bactive/;
		$inactive++ if $amactive =~ /inactive/;
		$alive++    if $amalive  =~ /running/;
		$dead++	    if $amalive  =~ /dead/;
		$exited++   if $amalive  =~ /exited/;
		$total++;
		$iter = $store->iter_next($iter);
	}
	my @stats2 = ();
	push @stats2, "<small><span foreground=\"green\">loaded\t$loaded</span></small>" if $loaded;
	push @stats2, "<small><span foreground=\"red\">error\t$error</span></small>" if $error;
	my @stats3 = ();
	push @stats3, "<small><span foreground=\"green\">active\t$active</span></small>" if $active;
	push @stats3, "<small><span foreground=\"blue\">inactive\t$inactive</span></small>" if $inactive;
	my @stats4 = ();
	push @stats4, "<small><span foreground=\"green\">alive\t$alive</span></small>" if $alive;
	push @stats4, "<small><span foreground=\"blue\">dead\t$dead</span></small>" if $dead;
	push @stats4, "<small><span foreground=\"black\">gone\t$exited</span></small>" if $exited;
	$store->set($piter,
		&Sd::UNIT_COLUMN_11,	"$ptype <small><span foreground=\"grey\">\t($total)</span></small>",
		&Sd::UNIT_COLUMN_2,	join("\n",@stats2),
		&Sd::UNIT_COLUMN_3,	join("\n",@stats3),
		&Sd::UNIT_COLUMN_4,	join("\n",@stats4),
	);
	return $self;
}
sub del {
	my $self = shift;
	my $store = get Sd::UnitModel;
	my $iter = delete $self->{iter};
	my $id = $self->{id};
	$store->{count}--;
	delete $store->{objects}{$id};
	$store->remove($iter);
}

# -----------------------------------------------------------
package Sd::UnitWindow;
use base qw(Gtk2::Window);
use Glib qw(TRUE FALSE);
use strict;

our $unitWindow;

sub get {
	return $unitWindow if $unitWindow;
	return new Sd::UnitWindow;
}
sub add_list_column {
	my ($view,$label,$id,$sort) = @_;
	my $renderer = Gtk2::CellRendererText->new;
	my $column = Gtk2::TreeViewColumn->new_with_attributes(
		$label,$renderer,text=>$id);
	$column->set_sort_column_id($id) if $sort;
	$view->append_column($column);
}
sub add_tree_column {
	my ($view,$label,$id,$sort) = @_;
	my $renderer = Gtk2::CellRendererText->new;
	my $offset = $view->insert_column_with_attributes(
			-1,$label,$renderer,markup=>$id);
	my $column = $view->get_column($offset - 1);
	$column->set_clickable(TRUE);
	$column->set_sort_column_id($id) if $sort;
}
sub new {
	my $self = bless Gtk2::Window->new('toplevel'), shift;
	$self->set_wmclass('sdUnits','SdApplet');
	$self->set_title('Units');
	$self->set_gravity('center');
	$self->set_icon_name('applications-system');
	$self->signal_connect(destroy=>sub{$unitWindow = undef; 1 });
	$self->set_border_width(8);

	my $hbox = Gtk2::HBox->new(FALSE,8);
	$self->add($hbox);

	my $sw1 = Gtk2::ScrolledWindow->new;
	$sw1->set_shadow_type('etched-in');
	$sw1->set_policy('never','automatic');
	$hbox->pack_start($sw1,TRUE,TRUE,0);

	my $model1 = Gtk2::ListStore->new(
		'Glib::String',
	);
	foreach my $kind (qw/Unit Automount Device Mount Path Service Socket Swap Target Timer/) {
		my $iter = $model1->append;
		$model1->set($iter,0,$kind);
	}

	my $view1 = Gtk2::TreeView->new($model1);
	$view1->set_rules_hint(FALSE);
	$view1->set_search_column(0);
	$sw1->add($view1);

	my @columns1 = (
		['Type',	0,				1],
	);

	foreach my $col (@columns1) { add_list_column($view1,@$col); }

	my $selection1 = $view1->get_selection;
	$selection1->signal_connect_swapped(changed=>$self->can('group_changed'),$self);

	foreach my $event ('button_press_event', 'row_activated') {
		$view1->signal_connect_swapped($event=>$self->can('group_'.$event),$self);
	}

	my $sw2 = Gtk2::ScrolledWindow->new;
	$sw2->set_shadow_type('etched-in');
	$sw2->set_policy('never','automatic');
	$hbox->pack_end($sw2,TRUE,TRUE,0);

	my $model = get Sd::UnitModel;

	my $view = Gtk2::TreeView->new($model);
	$view->set_rules_hint(TRUE);
	$view->set_search_column(&Sd::UNIT_COLUMN_0);
	$view->set_tooltip_column(&Sd::UNIT_COLUMN_0);
	$sw2->add($view);

	my @columns = (
#		['Type',	&Sd::UNIT_COLUMN_10,		1],
		['Id',		&Sd::UNIT_COLUMN_11,		1],
#		['Description',	&Sd::UNIT_COLUMN_1,		1],
		['LoadState',	&Sd::UNIT_COLUMN_2,		1],
		['ActiveState',	&Sd::UNIT_COLUMN_3,		1],
		['SubState',	&Sd::UNIT_COLUMN_4,		1],
#		['Following',	&Sd::UNIT_COLUMN_5,		1],
#		['DBus Node',	&Sd::UNIT_COLUMN_6,		1],
#		['Field 7',	&Sd::UNIT_COLUMN_7,		1],
#		['Field 8',	&Sd::UNIT_COLUMN_8,		1],
#		['DBus Node',	&Sd::UNIT_COLUMN_9,		1],
	);

	foreach my $col (@columns) { add_tree_column($view,@$col); }

	my $selection = $view->get_selection;
	$selection->signal_connect_swapped(changed=>$self->can('changed'),$self);

	foreach my $event ('button_press_event', 'row_activated') {
		$view->signal_connect_swapped($event=>$self->can($event),$self);
	}

	$self->set_default_size(-1,600);
	$self->show_all;

	$unitWindow = $self;
	return $self;
}

sub group_changed {
	my $self = shift;
	my ($selection) = @_;
	return Gtk2::EVENT_PROPAGATE;
}
sub group_button_press_event {
	my $self = shift;
	my ($ev,$view) = @_;
	return Gtk2::EVENT_PROPAGATE;
}
sub group_row_activated {
	my $self = shift;
	my ($path,$column,$view) = @_;
	return Gtk2::EVENT_PROPAGATE;
}

sub button_press_event {
	my $self = shift;
	my ($ev,$view) = @_;
	return Gtk2::EVENT_PROPAGATE unless $ev->button == 3;
	my ($path,$column) = $view->get_path_at_pos($ev->x,$ev->y);
	my $selection = $view->get_selection;
	$selection->select_path($path);
	my ($menu,$mi) = Gtk2::Menu->new;
	$mi = Gtk2::MenuItem->new_with_label("properties...");
	$mi->signal_connect(activate=>sub{
			Sd::UnitProps::show_props($selection);
		});
	$mi->show_all;
	$menu->append($mi);
	$mi = Gtk2::SeparatorMenuItem->new;
	$mi->show_all;
	$menu->append($mi);
	$mi = Gtk2::MenuItem->new_with_label("start");
	$mi->show_all;
	$menu->append($mi);
	$mi = Gtk2::MenuItem->new_with_label("stop");
	$mi->show_all;
	$menu->append($mi);
	$mi = Gtk2::MenuItem->new_with_label("reload");
	$mi->show_all;
	$menu->append($mi);
	$mi = Gtk2::MenuItem->new_with_label("restart");
	$mi->show_all;
	$menu->append($mi);
	$mi = Gtk2::MenuItem->new_with_label("try-restart");
	$mi->show_all;
	$menu->append($mi);
	$mi = Gtk2::MenuItem->new_with_label("reload-or-restart");
	$mi->show_all;
	$menu->append($mi);
	$mi = Gtk2::MenuItem->new_with_label("reload-or-try-restart");
	$mi->show_all;
	$menu->append($mi);
	$menu->popup(undef,undef,undef,undef,$ev->button,$ev->time);
	return Gtk2::EVENT_STOP;
}
sub changed {
	my $self = shift;
	Sd::UnitProps::show_props(shift) if $Sd::UnitProps::unitProps;
	return Gtk2::EVENT_PROPAGATE;
}
sub row_activated {
	my $self = shift;
	my ($path,$column,$view) = @_;
	Sd::UnitProps::show_props($view->get_selection);
	return Gtk2::EVENT_PROPAGATE;
}
sub test_expand_row {
	my $self = shift;
	print STDERR "test_expand_row: ",join(',',@_),"\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub test_collapse_row {
	my $self = shift;
	print STDERR "test_collapse_row: ",join(',',@_),"\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub row_expanded {
	my $self = shift;
	print STDERR "row_expanded: ",join(',',@_),"\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub row_collapsed {
	my $self = shift;
	print STDERR "row_collapsed: ",join(',',@_),"\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub select_cursor_row {
	my $self = shift;
	print STDERR "select_cursor_row: ",join(',',@_),"\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub toggle_cursor_row {
	my $self = shift;
	print STDERR "toggle_cursor_row: ",join(',',@_),"\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub expand_collapse_cursor_row {
	my $self = shift;
	print STDERR "expand_collapse_cursor_row: ",join(',',@_),"\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub select_cursor_parent {
	my $self = shift;
	print STDERR "select_cursor_parent: ",join(',',@_),"\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub start_interactive_search {
	my $self = shift;
	print STDERR "start_interactive_search: ",join(',',@_),"\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub button_release_event {
	my $self = shift;
	print STDERR "button_release_event: ",join(',',@_),"\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub selection_clear_event {
	my $self = shift;
	print STDERR "selection_clear_event: ",join(',',@_),"\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub selection_request_event {
	my $self = shift;
	print STDERR "selection_request_event: ",join(',',@_),"\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub selection_notify_event {
	my $self = shift;
	print STDERR "selection_notify_event: ",join(',',@_),"\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub query_tooltip_event {
	my $self = shift;
	print STDERR "query_tooltip_event: ",join(',',@_),"\n";
	return Gtk2::EVENT_PROPAGATE;
}


# -----------------------------------------------------------
package Sd::FileModel;
use base qw(Gtk2::TreeStore);
use strict;

our $fileModel;

sub get {
	return $fileModel if $fileModel;
	return new Sd::FileModel;
}
sub new {
	$fileModel = bless Gtk2::TreeStore->new(
		'Glib::String', # name
		'Glib::String', # status
		'Glib::String', # tooltip
	), shift;
	my $i = 0;
	foreach my $kind (qw/Automount Device Mount Path Service Socket Swap Target Timer/) {
		my $iter = $fileModel->append(undef);
		$fileModel->set($iter,&Sd::FILE_COLUMN_NAME,$kind);
		$fileModel->{index}{$kind} = $i;
		$i++;
	}
	return $fileModel;
}

# -----------------------------------------------------------
package Sd::File;
use strict;

sub new {
	my $self = bless {}, shift;
	my ($name,$status) = @_;
	$self->{name} = $name;
	$self->{status} = $status;

	my $utype = $name; $utype =~ s/^.*\.//;
	$self->{utype} = $utype;
	my $ptype = uc(substr($utype,0,1)).substr($utype,1,12);
	$self->{ptype} = $ptype;

	my $store = get Sd::FileModel;
	my $piter = $store->iter_nth_child(undef, $store->{index}{$ptype});
	my $iter = $store->append($piter);
	my $tooltip = $name;
	$name =~ s/\/systemd\/system\//\/...\//;
	$status = "<span foreground=\"green\">$status</span>" if $status =~ /enabled/;
	$status = "<span foreground=\"blue\">$status</span>" if $status =~ /disabled/;
	$status = "<span foreground=\"black\">$status</span>" if $status =~ /static/;
	$status = "<span foreground=\"red\">$status</span>" if $status =~ /masked/;
	$name = "<span foreground=\"green\">$name</span>" if $status =~ /enabled/;
	$name = "<span foreground=\"blue\">$name</span>" if $status =~ /disabled/;
	$name = "<span foreground=\"black\">$name</span>" if $status =~ /static/;
	$name = "<span foreground=\"red\">$name</span>" if $status =~ /masked/;
	$store->set($iter,
		&Sd::FILE_COLUMN_NAME,		$name,
		&Sd::FILE_COLUMN_STATUS,	$status,
		&Sd::FILE_COLUMN_TOOLTIP,	$tooltip,
	);
	$iter = $store->iter_nth_child($piter,0);
	my ($enabled,$disabled,$static,$masked,$total);
	while ($iter) {
		my ($amenabled) =
			$store->Gtk2::TreeModel::get($iter,
				&Sd::FILE_COLUMN_STATUS,
			);
		$enabled++  if $amenabled =~ /enabled/;
		$disabled++ if $amenabled =~ /disabled/;
		$static++   if $amenabled =~ /static/;
		$masked++   if $amenabled =~ /masked/;
		$total++;
		$iter = $store->iter_next($iter);
	}
	my @stats = ();
	push @stats, "<small><span foreground=\"green\">enabled\t$enabled</span></small>" if $enabled;
	push @stats, "<small><span foreground=\"blue\">disabled\t$disabled</span></small>" if $disabled;
	push @stats, "<small><span foreground=\"black\">static\t$static</span></small>" if $static;
	push @stats, "<small><span foreground=\"red\">masked\t$masked</span></small>" if $masked;
	$store->set($piter,
		&Sd::FILE_COLUMN_NAME,	    "$ptype <small><span foreground=\"grey\">\t($total)</span></small>",
		&Sd::FILE_COLUMN_STATUS,    join("\n",@stats),
	);
	return $self;
}

# -----------------------------------------------------------
package Sd::FileWindow;
use base qw(Gtk2::Window);
use Glib qw(TRUE FALSE);
use strict;

our $fileWindow;

sub get {
	return $fileWindow if $fileWindow;
	return new Sd::FileWindow;
}
sub add_list_column {
	my ($view,$label,$id,$sort) = @_;
	my $renderer = Gtk2::CellRendererText->new;
	my $column = Gtk2::TreeViewColumn->new_with_attributes(
		$label,$renderer,text=>$id);
	$column->set_sort_column_id($id) if $sort;
	$view->append_column($column);
}
sub add_tree_column {
	my ($view,$label,$id,$sort) = @_;
	my $renderer = Gtk2::CellRendererText->new;
	my $offset = $view->insert_column_with_attributes(
			-1,$label,$renderer,markup=>$id);
	my $column = $view->get_column($offset - 1);
	$column->set_clickable(TRUE);
	$column->set_sort_column_id($id) if $sort;
}
sub new {
	my $self = bless Gtk2::Window->new('toplevel'), shift;
	$self->set_wmclass('sdFiles','SdApplet');
	$self->set_title('Unit Files');
	$self->set_gravity('center');
	$self->set_icon_name('system-file-manager');
	$self->signal_connect(destroy=>sub{$fileWindow = undef; 1 });
	$self->set_border_width(8);

	my $vbox = Gtk2::VBox->new(FALSE,8);
	$self->add($vbox);

	my $vpane = Gtk2::VPaned->new;
	$vbox->pack_start($vpane,TRUE,TRUE,0);

	my $sw = Gtk2::ScrolledWindow->new;
	$sw->set_shadow_type('etched-in');
	$sw->set_policy('never','automatic');
	$vpane->pack1($sw,TRUE,TRUE);

	my $tw = Gtk2::ScrolledWindow->new;
	$tw->set_shadow_type('etched-in');
	$tw->set_policy('automatic','automatic');
	$vpane->pack2($tw,TRUE,TRUE);

	$vpane->set_position(400);

	my $buf = Gtk2::TextBuffer->new;
	$self->{textbuffer} = $buf;
	$buf->set_text('');
	my $tv = Gtk2::TextView->new_with_buffer($buf);
	$tv->set_editable(FALSE);
	$tw->add($tv);

	my $bb = Gtk2::HButtonBox->new;
	$bb->set_layout_default('start');
	$bb->set_spacing_default(5);
	$vbox->pack_end($bb,FALSE,FALSE,0);
	for (
		['gtk-add',	    'Enable',	    0, ],
		['gtk-remove',	    'Disable',	    0, ],
		['gtk-refresh',	    'Preset',	    0, ],
		['gtk-delete',	    'Delete',	    0, ],
		['gtk-edit',	    'Edit',	    0, ],
		['gtk-open',	    'View',	    0, ],
		['gtk-properties',  'Properties',   0, ],
	) {
		my $image = Gtk2::Image->new_from_icon_name($_->[0],'button');
		my $button = Gtk2::Button->new_with_label($_->[1]);
		$button->set_image($image);
		$button->set_sensitive($_->[2]);
		$button->signal_connect_swapped(clicked=>$self->can("button_".$_->[1]),$self);
		$self->{buttons}{$_->[1]} = $button;
		$bb->add($button);
	}

	my $model = get Sd::FileModel;

	my $view = Gtk2::TreeView->new($model);
	$self->{view} = $view;
	$view->set_rules_hint(TRUE);
	$view->set_search_column(&Sd::FILE_COLUMN_NAME);
	$view->set_tooltip_column(&Sd::FILE_COLUMN_TOOLTIP);
	$sw->add($view);

	my @columns = (
		['Name',	&Sd::FILE_COLUMN_NAME,		1],
		['Status',	&Sd::FILE_COLUMN_STATUS,	1],
	);

	foreach my $col (@columns) { add_tree_column($view,@$col); }

	my $path = Gtk2::TreePath->new_from_indices(4);
	$view->expand_row($path,TRUE);

	my $selection = $view->get_selection;
	$selection->set_mode('single');
	$selection->signal_connect_swapped(changed=>$self->can('selection_changed'),$self);

	foreach my $event ('row_activated') {
		$view->signal_connect_swapped($event=>$self->can($event),$self);
	}
	$self->set_default_size(-1,600);
	$self->show_all;

	$fileWindow = $self;
	return $self;
}
sub button_Enable {
	my $self = shift;
	my ($button) = @_;
	print STDERR "Enable button pressed!\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub button_Disable {
	my $self = shift;
	my ($button) = @_;
	print STDERR "Disable button pressed!\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub button_Preset {
	my $self = shift;
	my ($button) = @_;
	print STDERR "Preset button pressed!\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub button_Delete {
	my $self = shift;
	my ($button) = @_;
	print STDERR "Delete button pressed!\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub button_Edit {
	my $self = shift;
	my ($button) = @_;
	my $view = $self->{view};
	my $selection = $view->get_selection;
	my ($model,$iter) = $selection->get_selected;
	my $file = $model->Gtk2::TreeModel::get($iter,&Sd::FILE_COLUMN_TOOLTIP);
	if ($file) {
		if (fork() == 0) {
			exec("/usr/bin/gksudo","/usr/bin/xdg-open",$file);
			exit(0); # should never get here
		}
	}
	return Gtk2::EVENT_PROPAGATE;
}
sub button_View {
	my $self = shift;
	my ($button) = @_;
	my $view = $self->{view};
	my $selection = $view->get_selection;
	my ($model,$iter) = $selection->get_selected;
	my $file = $model->Gtk2::TreeModel::get($iter,&Sd::FILE_COLUMN_TOOLTIP);
	if ($file) {
		if (fork() == 0) {
			exec("/usr/bin/xdg-open",$file);
			exit(0); # should never get here
		}
	}
	return Gtk2::EVENT_PROPAGATE;
}
sub button_Properties {
	my $self = shift;
	my ($button) = @_;
	print STDERR "Properties button pressed!\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub markup_unitfile {
	my $text = shift;
	my $markup = $text;
	$markup =~ s{^(Description|Documentation|ConditionHost|RequiresMountsFor|Requires|RequiresOverridable|Requisite|RequisiteOverridable|Wants|BindTo|Conflicts|Before|After|OnFailure|Names)=}{<span foreground="blue">$1</span>}mg;
	$markup;
}
sub selection_changed {
	my $self = shift;
	my ($selection) = @_;
	my ($model,$iter) = $selection->get_selected;
	if ($model) {
		my ($name,$status,$fullname) = $model->Gtk2::TreeModel::get($iter,0,1,2);
		if ($fullname) {
			for (keys %{$self->{buttons}}) {
				$self->{buttons}{$_}->set_sensitive(1);
			}
			my $text = `cat $fullname`;
			unless ($text =~ /[[]Install[]]/) {
				$self->{buttons}{Enable}->set_sensitive(0);
			}
			$self->{textbuffer}->set_text($text);
			if ($fullname =~ m{^/usr}) {
				$self->{buttons}{Edit}->set_sensitive(0);
				$self->{buttons}{Delete}->set_sensitive(0);
			}
			if ($status =~ /disabled/) {
				$self->{buttons}{Disable}->set_sensitive(0);
			}
			elsif ($status =~ /enabled/) {
				$self->{buttons}{Enable}->set_sensitive(0);
			}
			elsif ($status =~ /static/) {
				$self->{buttons}{Disable}->set_sensitive(0);
			}
			elsif ($status =~ /masked/) {
				$self->{buttons}{Enable}->set_sensitive(0);
				$self->{buttons}{Disable}->set_sensitive(0);
			}
		} else {
			for (keys %{$self->{buttons}}) {
				$self->{buttons}{$_}->set_sensitive(0);
			}
			$self->{textbuffer}->set_text('');
		}
	} else {
		for (keys %{$self->{buttons}}) {
			$self->{buttons}{$_}->set_sensitive(0);
		}
	}
}
sub row_activated {
	my $self = shift;
	my ($path,$column,$view) = @_;
	my $model = $view->get_model;
	my $iter = $model->get_iter($path);
	my $file = $model->Gtk2::TreeModel::get($iter,&Sd::FILE_COLUMN_TOOLTIP);
	if ($file) {
		if (fork() == 0) {
			if ($file =~ m{^/etc}) {
				exec("/usr/bin/gksudo","/usr/bin/xdg-open",$file);
			} else {
				exec("/usr/bin/xdg-open",$file);
			}
			exit(0); # should never get here
		}
	}
}

# -----------------------------------------------------------
package Sd::About;
use strict;

sub show {
	Gtk2->show_about_dialog($main::app->{mainw},
		logo_icon_name=>'applications-system',
		program_name=>'sd-applet',
		version=>'0.01',
		comments=>'A little systemd applet.',
		copyright=>'Copyright (c) 2013  OpenSS7 Corporation.',
		website=>'http://www.unexicon.com/',
		website_label=>'Unexicon - Linux spun for telecom',
		authors=>['Brian F. G. Bidulock <bidulock@openss7.org>'],
		license=><<EOF,
Do what thou wilt shall be the whole of the law.

-- Aleister Crowley
EOF
		# logo=>,
	);
}

# -----------------------------------------------------------
package Sd::Notify;
use base qw(Gtk2::Notify);
use strict;

sub new {
	my $self = bless Gtk2::Notify->new("Systemd","Systemd notification","applications-system"), shift;
	$self->signal_connect_swapped(closed=>$self->can('closed'),$self);
	$self->{state} = 0;
	$self->show;
	return $self;
}
sub closed {
	my ($self,$notify) = @_;
	$self->{state} = 0;
	return Gtk2::EVENT_PROPAGATE;
}

# -----------------------------------------------------------
package Sd::Icon;
use base qw(Gtk2::StatusIcon);
use strict;

sub new {
	my $self = bless Gtk2::StatusIcon->new_from_icon_name('applications-system'), shift;
	$self->{notify} = Sd::Notify->new($self);
	$self->set_tooltip_text('Systemd applet.');
	$self->set_visible(1);
	foreach my $sig ('popup_menu', 'activate', 'query_tooltip') {
		$self->signal_connect($sig=>$self->can($sig));
	}
	return $self;
}
sub query_tooltip {
	my ($self,$x,$y,$bool,$tooltip) = @_;
#	print "query-tooltip: ",join(', ',@_),"\n";
#	print "Tooltip query!\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub activate {
	my ($self) = @_;
	my $window = get Sd::UnitWindow;
	$window->deiconify;
	$window->show;
	return Gtk2::EVENT_PROPAGATE;
}
sub popup_menu {
	my ($self,$button,$time) = @_;
	my ($menu,$mi,$im) = Gtk2::Menu->new;
	$mi = Gtk2::ImageMenuItem->new_with_label('Units...');
	$mi->signal_connect(activate=>sub{ get Sd::UnitWindow; 1; });
	$im = Gtk2::Image->new_from_icon_name('applications-system','menu');
	$mi->set_image($im);
	$mi->show_all;
	$menu->append($mi);
	$mi = Gtk2::ImageMenuItem->new_with_label('Files...');
	$mi->signal_connect(activate=>sub{ get Sd::FileWindow; 1; });
	$im = Gtk2::Image->new_from_icon_name('system-file-manager','menu');
	$mi->set_image($im);
	$mi->show_all;
	$menu->append($mi);
	$mi = Gtk2::ImageMenuItem->new_with_label('About...');
	$mi->signal_connect(activate=>sub{ Sd::About->show; });
	$im = Gtk2::Image->new_from_stock('gtk-about','menu');
	$mi->set_image($im);
	$mi->show_all;
	$menu->append($mi);
	$mi = Gtk2::SeparatorMenuItem->new;
	$mi->show_all;
	$menu->append($mi);
	$mi = Gtk2::ImageMenuItem->new_with_label('Quit');
	$im = Gtk2::Image->new_from_stock('gtk-quit','menu');
	$mi->set_image($im);
	$mi->show_all;
	$mi->signal_connect(activate=>sub{ Gtk2->main_quit(); 1; });
	$menu->append($mi);
	$menu->popup(undef,undef,undef,undef,$button,$time);
	return Gtk2::EVENT_PROPAGATE;
}
sub button_press_event {
	my ($self,$event) = @_;
#	print "button-press-event: ",join(', ',@_),"\n";
#	print "Button pressed!\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub button_release_event {
	my ($self,$event) = @_;
#	print "button-release-event: ",join(', ',@_),"\n";
#	print "Button released!\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub scroll_event {
	my ($self,$event) = @_;
#	print "scroll-event: ",join(', ',@_),"\n";
#	print "Scroll!\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub size_changed {
	my ($self,$pixels) = @_;
#	print "size-changed: ",join(', ',@_),"\n";
#	print "Size changed to $pixels!\n";
	return Gtk2::EVENT_PROPAGATE;
}

# -----------------------------------------------------------
package Sd::Application;
use base qw(Gtk2::UniqueApp);
use Glib qw(TRUE FALSE);
use strict;

use constant {
	COMMAND_APPLET	=> 1,
	COMMAND_UNITS	=> 2,
	COMMAND_FILES	=> 3,
};

sub new {
	my $self = bless Gtk2::UniqueApp->new(
		'com.unexicon.SdApplet', undef,
		'sd-applet' => &COMMAND_APPLET,
		'sd-units'  => &COMMAND_UNITS,
		'sd-files'  => &COMMAND_FILES,
	), shift;
	if ($self->is_running) {
		my $cmd = $0; $cmd =~ s/^.*\///;
		$self->send_message_by_name($cmd=>text=>join('|',$0,@ARGV));
		print STDERR "Another instance of $cmd is already running.\n";
		exit(0);
	}
	$self->{mainw} = Gtk2::Window->new('toplevel');
	$self->{mainw}->set_wmclass('sdApplet','SdApplet');
	$self->{mainw}->set_default_icon_name('applications-system');
	$self->watch_window($self->{mainw});
	$self->signal_connect(message_received=>
		$self->can('message_received'));
	$self->{icon} = new Sd::Icon;

	$self->{files} = {};
	$self->{units} = {};
	my $mngr = $self->{mngr} = Sd::Manager->new($self);
	$self->ListUnitFiles;
	$self->ListUnits;
	return $self;
}

sub message_received {
	my ($self,$command,$message,$time) = @_;
	if ($command == &COMMAND_UNITS) {
		my $win = get Sd::UnitWindow;
		$win->set_screen($message->get_screen);
	} elsif ($command == &COMMAND_FILES) {
		my $win = get Sd::FileWindow;
		$win->set_screen($message->get_screen);
	} elsif ($command == &COMMAND_APPLET) {
		my $text = $message->get_text;
		my @args = split(/\|/,$text);
		my $prog = shift @args;
		print STDERR "Another instance was executed as $prog ",join(' ',@args),"\n";
	} else {
		print STDERR "Bad command value $command\n";
	}
	Gtk2::Gdk->notify_startup_complete_with_id($message->get_startup_id);
	return 'ok';
}

sub ListUnitFiles {
	my $self = shift;
	my $mngr = $self->{mngr};
	my $files = $mngr->ListUnitFiles;
	foreach my $file (@$files) {
		my ($name,$status) = @$file;
		$self->{files}{$name} =
			Sd::File->new($name,$status)
			unless exists $self->{files}{$name}
				  and $self->{files}{$name};
	}
}
sub ListUnits {
	my $self = shift;
	my $mngr = $self->{mngr};
	my $units = $mngr->ListUnits;
	foreach my $unit (@$units) {
		$self->{units}{$unit->[0]} =
			Sd::Unit->new($self,@$unit)
			unless exists $self->{units}{$unit->[0]}
				  and $self->{units}{$unit->[0]};
	}
}

sub UnitNew {
	my $self = shift;
	my $mngr = shift;
	my ($id,$unit) = @_;
	$self->{units}{$id} =
		Sd::Unit->new($self,$id,undef,undef,undef,undef,undef,$unit,undef,undef,undef)
		unless exists $self->{units}{$id}
			  and $self->{units}{$id};
}
sub UnitRemoved {
	my $self = shift;
	my $mngr = shift;
	my ($id,$unit) = @_;
	my $object = delete $self->{units}{$id};
	$object->del if $object;
}
sub JobNew {
	my $self = shift;
	my $mngr = shift;
	my ($id,$job,$unit) = @_;
	print STDERR "JobNew: ",join(',',@_),"\n";
}
sub JobRemoved {
	my $self = shift;
	my $mngr = shift;
	my ($id,$job,$unit) = @_;
	print STDERR "JobRemoved: ",join(',',@_),"\n";
}
sub StartupFinished {
	my $self = shift;
	my $mngr = shift;
	my ($firmware,$loader,$kernel,$initrd,$userspace,$total) = @_;
	print STDERR "StartupFinished: ",join(',',@_),"\n";
}
sub UnitFilesChanged {
	my $self = shift;
	my $mngr = shift;
	print STDERR "UnitFilesChanged: ",join(',',@_),"\n";
}
sub PropertiesChanged {
	my $self = shift;
	my $mngr = shift;
	my ($interface,$changed,$invalidated) = @_;
	print STDERR "PropertiesChanged: ",join(',',@_),"\n";
	foreach my $prop (@$invalidated) {
		my $old = delete $self->{properties}{$prop};
		print STDERR "  $prop = $old REMOVED\n";
	}
	foreach my $prop (keys %$changed) {
		my $old = $self->{properties}{$prop}
			if exists $self->{properties}{$prop};
		my $new = $changed->{$prop};
		$self->{properties}{$prop} = $new;
		print STDERR "$  prop = $old -> $new\n";
	}
}

# -----------------------------------------------------------
package main;
use strict;

$app = Sd::Application->new;

Gtk2->main;

1;

__END__

=head1 SYNOPSIS

sd-applet

=head1 DESCRIPTION

B<sd-applet> is a small perl Gtk2 application that installs an icon
into the system tray and provides the ability to manage systemd unit
files and active units using a graphical interface.  It also provides
for desktop notifications when unit files or the status of units changes.

=head1 SEE ALSO

systemd(8)

=head1 LICENSE

perl

=head1 AUTHOR

Brian F. G. Bidulock <bidulock@openss7.org>

=cut
